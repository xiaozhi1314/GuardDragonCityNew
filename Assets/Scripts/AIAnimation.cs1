using System;
using UnityEngine;

public class AIAnimation : MonoBehaviour
{
	private void OnEnable()
	{
		this._chooseNewAction = true;
		base.transform.forward = new Vector3(UnityEngine.Random.value - 0.5f, 0f, UnityEngine.Random.value - 0.5f);
	}
	
	public void Tick(float time, float deltaTime)
	{
		this.PerformAction(time, deltaTime);
	}

	private void PerformAction(float time, float deltaTime)
	{
		if (this.meshAnimator == null)
		{
			return;
		}
		if (this._chooseNewAction)
		{
			this._chooseNewAction = false;
			this._currentAction = this.actions[UnityEngine.Random.Range(0, this.actions.Length)];
			if (this._currentAction.type == AIAnimation.ActionType.move)
			{
				if (AIAnimation._movingUnits > AIAnimation._maxMovingUnits)
				{
					this._currentAction = this.actions[0];
				}
				else
				{
					AIAnimation._movingUnits++;
				}
			}
			string animationName = null;
			if (this._currentAction.animations.Length != 0)
			{
				animationName = this._currentAction.animations[UnityEngine.Random.Range(0, this._currentAction.animations.Length)].animationName;
				this.meshAnimator.Play(animationName, -1f);
			}
			switch (this._currentAction.type)
			{
			case AIAnimation.ActionType.idle:
				this._actionEndTime = time + 5f;
				break;
			case AIAnimation.ActionType.move:
				this._currentPosition = base.transform.position;
				this._movePosition = this._currentPosition + new Vector3(UnityEngine.Random.Range(-1f, 1f) * this.maxMoveDistance, 0f, UnityEngine.Random.Range(-1f, 1f) * this.maxMoveDistance);
				base.transform.LookAt(this._movePosition);
				break;
			case AIAnimation.ActionType.die:
			{
				this._actionEndTime = time + this.meshAnimator.GetClip(animationName).Length;
				Action<string> dieAction = null;
				dieAction = delegate(string anim)
				{
					MeshAnimatorBase meshAnimatorBase2 = this.meshAnimator;
					meshAnimatorBase2.OnAnimationFinished = (Action<string>)Delegate.Remove(meshAnimatorBase2.OnAnimationFinished, dieAction);
					this.gameObject.SetActive(false);
				};
				MeshAnimatorBase meshAnimatorBase = this.meshAnimator;
				meshAnimatorBase.OnAnimationFinished = (Action<string>)Delegate.Combine(meshAnimatorBase.OnAnimationFinished, dieAction);
				break;
			}
			case AIAnimation.ActionType.attack:
				this._actionEndTime = time + this.meshAnimator.GetClip(animationName).Length;
				break;
			}
		}
		if (this._currentAction.type == AIAnimation.ActionType.move)
		{
			this._currentPosition = Vector3.MoveTowards(this._currentPosition, this._movePosition, deltaTime * this.moveSpeed);
			if (this._currentPosition == this._movePosition)
			{
				this._actionEndTime = 0f;
				AIAnimation._movingUnits--;
			}
			else
			{
				this._actionEndTime = time;
			}
			try
			{
				base.transform.position = this._currentPosition;
			}
			catch
			{
			}
		}
		if (Time.time > this._actionEndTime)
		{
			this._chooseNewAction = true;
		}
	}

	private static int _maxMovingUnits = 5000;

	private static int _movingUnits = 0;

	public MeshAnimatorBase meshAnimator;

	public AIAnimation.AIAction[] actions;

	public float maxMoveDistance = 20f;

	public float moveSpeed = 1f;

	private bool _chooseNewAction = true;

	private AIAnimation.AIAction _currentAction;

	private float _actionEndTime;

	private Vector3 _currentPosition;

	private Vector3 _movePosition;

	public enum ActionType
	{
		idle,
		move,
		die,
		attack
	}

	[Serializable]
	public struct AIAction
	{
		public AIAnimation.ActionType type;

		public MeshAnimationBase[] animations;
	}
}
